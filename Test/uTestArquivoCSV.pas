unit uTestArquivoCSV;
{
  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.
}

interface

uses
  TestFramework,
  uConstantesGerais,
  uArquivoCSVLinha,
  System.Types,
  System.SysUtils,
  System.IOUtils,
  uLogErro,
  uFuncoes,
  FireDAC.Comp.Client,
  uArquivoCSV,
  Data.DB,
  System.Classes,
  uConstantesBaseDados,
  Winapi.Windows;

type
  // Test methods for class TArquivoCSV
  TestTArquivoCSV = class(TTestCase)
  strict private
    FArquivoCSV: TArquivoCSV;
    FDiretorioTeste: string;
    function CriarArquivoCSVDeTeste(const ConteudoCSV: string; const NomeArquivo: string): string;
    procedure ExcluirArquivoDeTeste(const NomeArquivo: string);
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestBuscarCarregarPlanilhaEstado_Sucesso;
    procedure TestBuscarCarregarPlanilhaEstado_ArquivoNaoEncontrado;
    procedure TestLerArquivo_Sucesso;
    procedure TestLerArquivo_ArquivoNaoEncontrado;
    procedure TestEscreverArquivo_Sucesso;
    procedure TestEscreverArquivo_ComDados;
  end;

implementation

uses
  System.StrUtils;

procedure TestTArquivoCSV.SetUp;
begin
  // Inicializa o diretório de testes
  FDiretorioTeste := TPath.Combine(TDirectory.GetCurrentDirectory, 'testes_csv');
  if not TDirectory.Exists(FDiretorioTeste) then
    TDirectory.CreateDirectory(FDiretorioTeste);
  FArquivoCSV := TArquivoCSV.Create('XX'); //Passa um valor qualquer, o arquivo será criado no teste
end;

procedure TestTArquivoCSV.TearDown;
begin
  FArquivoCSV.Free;
  FArquivoCSV := nil;
  // Limpa o diretório de testes após a execução dos testes
  if TDirectory.Exists(FDiretorioTeste) then
  begin
    for var NomeArquivo in TDirectory.GetFiles(FDiretorioTeste) do
      TFile.Delete(NomeArquivo);
    TDirectory.Delete(FDiretorioTeste);
  end;
end;

function TestTArquivoCSV.CriarArquivoCSVDeTeste(const ConteudoCSV: string; const NomeArquivo: string): string;
var
  CaminhoCompleto: string;
begin
  CaminhoCompleto := TPath.Combine(FDiretorioTeste, NomeArquivo);
  TFile.WriteAllText(CaminhoCompleto, ConteudoCSV);
  Result := CaminhoCompleto;
end;

procedure TestTArquivoCSV.ExcluirArquivoDeTeste(const NomeArquivo: string);
var
  CaminhoCompleto: string;
begin
  CaminhoCompleto := TPath.Combine(FDiretorioTeste, NomeArquivo);
  if TFile.Exists(CaminhoCompleto) then
  begin
    TFile.Delete(CaminhoCompleto);
  end;
end;


procedure TestTArquivoCSV.TestBuscarCarregarPlanilhaEstado_Sucesso;
var
  NomeArquivoCSV: string;
  ConteudoCSV: string;
  Result: Boolean;
begin
  // Cria um arquivo CSV de teste
  ConteudoCSV := 'CODIGO;DESCRICAO;NCM;UF;EX;TIPO;TRIBNACIONALFEDERAL;TRIBIMPORTADOSFEDERAL;TRIBESTADUAL;TRIBMUNICIPAL;VIGENCIAINICIO;VIGENCIAFIM;CHAVE;VERSAO;FONTE' + sLineBreak +
               '1;Produto A;12345678;SP;1;1;10.00;5.00;2.00;1.00;01/01/2023;31/12/2023;CHAVE123;1.0;FONTE1';
  NomeArquivoCSV := CriarArquivoCSVDeTeste(ConteudoCSV, 'IBPTax_20.5.B_SP.csv');

  try
    // Chama o método para buscar e carregar a planilha
    Result := FArquivoCSV.BuscarCarregarPlanilhaEstado('SP');
    Check(Result, 'Deveria encontrar e carregar a planilha do estado.');
    Check(TFile.Exists(NomeArquivoCSV), 'O arquivo CSV de teste deveria existir.');
  finally
    ExcluirArquivoDeTeste(NomeArquivoCSV);
  end;
end;

procedure TestTArquivoCSV.TestBuscarCarregarPlanilhaEstado_ArquivoNaoEncontrado;
var
  Result: Boolean;
begin
  // Chama o método para buscar um arquivo que não existe
  Result := FArquivoCSV.BuscarCarregarPlanilhaEstado('inexistente');
  Check(not Result, 'Não deveria encontrar uma planilha com nome inexistente.');
end;

procedure TestTArquivoCSV.TestLerArquivo_Sucesso;
var
  NomeArquivoCSV: string;
  ConteudoCSV: string;
  MemTable: TFDMemTable;
begin
  // Cria um arquivo CSV de teste
  ConteudoCSV := 'CODIGO;DESCRICAO;NCM;UF;EX;TIPO;TRIBNACIONALFEDERAL;TRIBIMPORTADOSFEDERAL;TRIBESTADUAL;TRIBMUNICIPAL;VIGENCIAINICIO;VIGENCIAFIM;CHAVE;VERSAO;FONTE' + sLineBreak +
               '1;Produto A;12345678;SP;1;1;10,00;5,00;2,00;1,00;01/01/2023;31/12/2023;CHAVE123;1.0;FONTE1' + sLineBreak +
               '2;Produto B;98765432;RJ;2;2;20,00;10,00;4,00;2,00;02/01/2023;28/02/2023;CHAVE456;2.0;FONTE2';
  NomeArquivoCSV := CriarArquivoCSVDeTeste(ConteudoCSV, 'dados_produtos.csv');

  FArquivoCSV.NomeArquivo := NomeArquivoCSV; //Seta o nome do arquivo a ser lido
  try
    // Chama o método para ler o arquivo
    FArquivoCSV.LerArquivo();
    MemTable := FArquivoCSV.Dados;

    // Verifica se os dados foram lidos corretamente
    Check(MemTable.RecordCount = 2, 'Deveria ter lido 2 registros do arquivo CSV.');

    // Verifica os valores do primeiro registro
    MemTable.First;
    Check(MemTable.FieldByName('CODIGO').AsInteger = 1, 'Código do primeiro registro incorreto.');
    Check(MemTable.FieldByName('DESCRICAO').AsString = 'Produto A', 'Descrição do primeiro registro incorreta.');
    Check(MemTable.FieldByName('UF').AsString = 'SP', 'UF do primeiro registro incorreta.');


    // Verifica os valores do segundo registro
    MemTable.Next;
    Check(MemTable.FieldByName('CODIGO').AsInteger = 2, 'Código do segundo registro incorreto.');
    Check(MemTable.FieldByName('DESCRICAO').AsString = 'Produto B', 'Descrição do segundo registro incorreta.');
    Check(MemTable.FieldByName('UF').AsString = 'RJ', 'UF do segundo registro incorreta.');

  finally
    ExcluirArquivoDeTeste(NomeArquivoCSV);
  end;
end;

procedure TestTArquivoCSV.TestLerArquivo_ArquivoNaoEncontrado;
begin
  // Define um nome de arquivo que não existe
  FArquivoCSV.NomeArquivo := 'arquivo_inexistente.csv';
  // Chama o método LerArquivo e verifica se a exception esperada foi levantada
  try
    FArquivoCSV.LerArquivo();
    Check(False, 'Deveria ter levantado uma exception para arquivo não encontrado.');
  except
    on E: Exception do
      Check(E.Message.Contains(ARQUIVO_NAO_ENCONTRADO), 'Deveria retornar erro de arquivo não encontrado');
  end;
end;

procedure TestTArquivoCSV.TestEscreverArquivo_Sucesso;
var
  NomeArquivoCSV: string;
  ConteudoEsperado: string;
  ConteudoArquivo: string;
begin
  // Cria um arquivo CSV de teste (vazio, para usar como base)
  NomeArquivoCSV := TPath.Combine(FDiretorioTeste, 'arquivo_escrita_teste.csv');
  TFile.Create(NomeArquivoCSV);

  // Define o conteúdo esperado do arquivo CSV
  ConteudoEsperado := 'Codigo;Ex;Tipo;Descricao;NacionalFederal;ImportadosFederal;Estadual;Municipal;VigenciaInicio;VigenciaFim;Chave;Versao;Fonte' + sLineBreak;

  FArquivoCSV.Dados.FieldDefs.Clear;
  FArquivoCSV.Dados.FieldDefs.Add(cUF, ftString, INT_2);
  FArquivoCSV.Dados.FieldDefs.Add(cCODIGONCM, ftInteger);
  FArquivoCSV.Dados.FieldDefs.Add(cEX, ftInteger);
  FArquivoCSV.Dados.FieldDefs.Add(cTIPO, ftInteger);
  FArquivoCSV.Dados.FieldDefs.Add(cDESCRICAO, ftString, INT_100);
  FArquivoCSV.Dados.FieldDefs.Add(cTRIBNACIONALFEDERAL, ftCurrency);
  FArquivoCSV.Dados.FieldDefs.Add(cTRIBIMPORTADOSFEDERAL, ftCurrency);
  FArquivoCSV.Dados.FieldDefs.Add(cTRIBESTADUAL, ftCurrency);
  FArquivoCSV.Dados.FieldDefs.Add(cTRIBMUNICIPAL, ftCurrency);
  FArquivoCSV.Dados.FieldDefs.Add(cVIGENCIAINICIO, ftDateTime);
  FArquivoCSV.Dados.FieldDefs.Add(cVIGENCIAFIM, ftDateTime);
  FArquivoCSV.Dados.FieldDefs.Add(cCHAVE, ftString, INT_255);
  FArquivoCSV.Dados.FieldDefs.Add(cVERSAO, ftString, INT_20);
  FArquivoCSV.Dados.FieldDefs.Add(cFONTE, ftString, INT_255);
  FArquivoCSV.Dados.CreateDataSet;
  FArquivoCSV.Dados.Open;

  try
    // Chama o método para escrever o arquivo
    FArquivoCSV.EscreverArquivo(NomeArquivoCSV);

    // Lê o conteúdo do arquivo gerado
    ConteudoArquivo := TFile.ReadAllText(NomeArquivoCSV);

    // Verifica se o conteúdo é o esperado
    Check(ConteudoArquivo = ConteudoEsperado, 'Conteúdo do arquivo escrito incorreto.');
  finally
    ExcluirArquivoDeTeste(NomeArquivoCSV);
  end;
end;

procedure TestTArquivoCSV.TestEscreverArquivo_ComDados;
var
  NomeArquivoCSV: string;
  ConteudoEsperado: string;
  ConteudoArquivo: string;
begin
  // Cria um arquivo CSV de teste
  NomeArquivoCSV := CriarArquivoCSVDeTeste('', 'arquivo_escrita_com_dados_teste.csv');

  // Define o conteúdo esperado do arquivo CSV
  ConteudoEsperado := 'Codigo;Ex;Tipo;Descricao;NacionalFederal;ImportadosFederal;Estadual;Municipal;VigenciaInicio;VigenciaFim;Chave;Versao;Fonte' + sLineBreak +
                    '1;1;1;Produto A;10,00;5,00;2,00;1,00;01/01/2024;31/12/2024;CHAVE123;1.0;FONTE1' + sLineBreak +
                    '2;2;2;Produto B;20,00;10,00;4,00;2,00;01/01/2025;31/12/2025;CHAVE456;2.0;FONTE2' + sLineBreak;

  FArquivoCSV.Dados.FieldDefs.Clear;
  FArquivoCSV.Dados.FieldDefs.Add(cUF, ftString, INT_2);
  FArquivoCSV.Dados.FieldDefs.Add(cCODIGONCM, ftInteger);
  FArquivoCSV.Dados.FieldDefs.Add(cEX, ftInteger);
  FArquivoCSV.Dados.FieldDefs.Add(cTIPO, ftInteger);
  FArquivoCSV.Dados.FieldDefs.Add(cDescricao, ftString, INT_100);
  FArquivoCSV.Dados.FieldDefs.Add(cTRIBNACIONALFEDERAL, ftCurrency);
  FArquivoCSV.Dados.FieldDefs.Add(cTRIBIMPORTADOSFEDERAL, ftCurrency);
  FArquivoCSV.Dados.FieldDefs.Add(cTRIBESTADUAL, ftCurrency);
  FArquivoCSV.Dados.FieldDefs.Add(cTRIBMUNICIPAL, ftCurrency);
  FArquivoCSV.Dados.FieldDefs.Add(cVIGENCIAINICIO, ftDateTime);
  FArquivoCSV.Dados.FieldDefs.Add(cVIGENCIAFIM, ftDateTime);
  FArquivoCSV.Dados.FieldDefs.Add(cCHAVE, ftString, INT_255);
  FArquivoCSV.Dados.FieldDefs.Add(cVERSAO, ftString, INT_20);
  FArquivoCSV.Dados.FieldDefs.Add(cFONTE, ftString, INT_255);
  FArquivoCSV.Dados.CreateDataSet;
  FArquivoCSV.Dados.Open;

  // Adiciona dados ao FDMemTable
  FArquivoCSV.Dados.Append;
  FArquivoCSV.Dados.FieldByName(cCODIGONCM).AsInteger := 1;
  FArquivoCSV.Dados.FieldByName(cEX).AsInteger := 1;
  FArquivoCSV.Dados.FieldByName(cTIPO).AsInteger := 1;
  FArquivoCSV.Dados.FieldByName(cDESCRICAO).AsString := 'Produto A';
  FArquivoCSV.Dados.FieldByName(cTRIBNACIONALFEDERAL).AsCurrency := 10.00;
  FArquivoCSV.Dados.FieldByName(cTRIBIMPORTADOSFEDERAL).AsCurrency := 5.00;
  FArquivoCSV.Dados.FieldByName(cTRIBESTADUAL).AsCurrency := 2.00;
  FArquivoCSV.Dados.FieldByName(cTRIBMUNICIPAL).AsCurrency := 1.00;
  FArquivoCSV.Dados.FieldByName(cVIGENCIAINICIO).AsDateTime := EncodeDate(2024, 1, 1);
  FArquivoCSV.Dados.FieldByName(cVIGENCIAFIM).AsDateTime := EncodeDate(2024, 12, 31);
  FArquivoCSV.Dados.FieldByName(cCHAVE).AsString := 'CHAVE123';
  FArquivoCSV.Dados.FieldByName(cVERSAO).AsString := '1.0';
  FArquivoCSV.Dados.FieldByName(cFONTE).AsString := 'FONTE1';
  FArquivoCSV.Dados.Post;

  FArquivoCSV.Dados.Append;
  FArquivoCSV.Dados.FieldByName(cCODIGONCM).AsInteger := 2;
  FArquivoCSV.Dados.FieldByName(cEX).AsInteger := 2;
  FArquivoCSV.Dados.FieldByName(cTIPO).AsInteger := 2;
  FArquivoCSV.Dados.FieldByName(cDESCRICAO).AsString := 'Produto B';
  FArquivoCSV.Dados.FieldByName(cTRIBNACIONALFEDERAL).AsCurrency := 20.00;
  FArquivoCSV.Dados.FieldByName(cTRIBIMPORTADOSFEDERAL).AsCurrency := 10.00;
  FArquivoCSV.Dados.FieldByName(cTRIBESTADUAL).AsCurrency := 4.00;
  FArquivoCSV.Dados.FieldByName(cTRIBMUNICIPAL).AsCurrency := 2.00;
  FArquivoCSV.Dados.FieldByName(cVIGENCIAINICIO).AsDateTime := EncodeDate(2025, 1, 1);
  FArquivoCSV.Dados.FieldByName(cVIGENCIAFIM).AsDateTime := EncodeDate(2025, 12, 31);
  FArquivoCSV.Dados.FieldByName(cCHAVE).AsString := 'CHAVE456';
  FArquivoCSV.Dados.FieldByName(cVERSAO).AsString := '2.0';
  FArquivoCSV.Dados.FieldByName(cFONTE).AsString := 'FONTE2';
  FArquivoCSV.Dados.Post;

  try
    // Chama o método para escrever o arquivo
    FArquivoCSV.EscreverArquivo(NomeArquivoCSV);

    // Lê o conteúdo do arquivo gerado
    ConteudoArquivo := TFile.ReadAllText(NomeArquivoCSV);

    // Verifica se o conteúdo é o esperado
    Check(ConteudoArquivo = ConteudoEsperado, 'Conteúdo do arquivo escrito incorreto.');
  finally
    ExcluirArquivoDeTeste(NomeArquivoCSV);
  end;
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTArquivoCSV.Suite);
end.

